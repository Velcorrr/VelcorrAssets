<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High Detail Mood Scene</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; }
        canvas { display: block; }
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #88aaee; font-family: monospace; font-size: 1.5rem; pointer-events: none;
            text-shadow: 0 0 10px #0044ff;
            transition: opacity 1s;
        }
    </style>
</head>
<body>
    <div id="loader">Rendering Scene Details...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        // Thick, murky underwater fog
        scene.fog = new THREE.FogExp2(0x020408, 0.04);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
        // Positioned to look over the TV shoulder
        camera.position.set(-3.5, 2.2, 9.5); 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        RectAreaLightUniformsLib.init();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0.5, 1, 0);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 1.9; // Don't go below ground
        controls.minDistance = 2;
        controls.maxDistance = 15;

        // --- TEXTURE GENERATION ---
        // We generate high-res procedural textures on the fly
        function createCanvasTexture(width, height, painter) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            painter(ctx, width, height);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function noise(ctx, w, h, intensity = 20, color = null) {
            if(color) {
                ctx.fillStyle = color;
                ctx.fillRect(0,0,w,h);
            }
            const iData = ctx.getImageData(0,0,w,h);
            for(let i=0; i<iData.data.length; i+=4){
                const v = (Math.random()-0.5) * intensity;
                iData.data[i] += v;
                iData.data[i+1] += v;
                iData.data[i+2] += v;
            }
            ctx.putImageData(iData, 0, 0);
        }

        // 1. Sponge Texture (Pores + Dirt)
        const spongeMap = createCanvasTexture(1024, 1024, (ctx, w, h) => {
            // Base yellow-ish dirt
            ctx.fillStyle = '#bba830';
            ctx.fillRect(0,0,w,h);
            noise(ctx, w, h, 40);
            
            // Large Pores
            for(let i=0; i<60; i++){
                const x = Math.random()*w;
                const y = Math.random()*h;
                const r = Math.random() * 40 + 10;
                // Shadow for depth
                const g = ctx.createRadialGradient(x,y, r*0.2, x,y, r);
                g.addColorStop(0, 'rgba(60, 50, 10, 0.9)'); // Deep hole
                g.addColorStop(1, 'rgba(180, 160, 50, 0)'); 
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
            }
            // Stubble/Dirt patches
            ctx.globalCompositeOperation = 'multiply';
            for(let i=0; i<500; i++){
                ctx.fillStyle = 'rgba(50,40,20,0.1)';
                ctx.fillRect(Math.random()*w, Math.random()*h, 4, 4);
            }
        });
        const matSponge = new THREE.MeshStandardMaterial({ 
            map: spongeMap, 
            bumpMap: spongeMap, 
            bumpScale: 0.15,
            roughness: 0.9,
            color: 0xddcc55
        });

        // 2. Worn Chair Texture
        const chairMap = createCanvasTexture(512, 512, (ctx, w, h) => {
            ctx.fillStyle = '#7a2222';
            ctx.fillRect(0,0,w,h);
            noise(ctx, w, h, 60);
            // Scratches
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            for(let i=0; i<50; i++){
                ctx.beginPath();
                ctx.moveTo(Math.random()*w, Math.random()*h);
                ctx.lineTo(Math.random()*w, Math.random()*h);
                ctx.stroke();
            }
        });
        const matChair = new THREE.MeshStandardMaterial({ map: chairMap, roughness: 0.6, bumpMap: chairMap, bumpScale: 0.02 });
        const matChairWhite = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.7, map: chairMap });

        // 3. Sand Texture
        const sandMap = createCanvasTexture(1024, 1024, (ctx, w, h) => {
            ctx.fillStyle = '#2b261c';
            ctx.fillRect(0,0,w,h);
            noise(ctx, w, h, 80);
        });
        const matSand = new THREE.MeshStandardMaterial({ map: sandMap, bumpMap: sandMap, bumpScale: 0.5, roughness: 1.0 });

        // 4. Gary's Shell
        const shellMap = createCanvasTexture(512, 512, (ctx, w, h) => {
            ctx.fillStyle = '#eebbc9';
            ctx.fillRect(0,0,w,h);
            noise(ctx, w, h, 30);
            // Spirals painted manually on geometry or simple patterns here
            ctx.strokeStyle = '#a34d6b';
            ctx.lineWidth = 20;
            ctx.beginPath();
            for(let i=0; i<w; i+=20) {
                ctx.moveTo(i, 0); ctx.lineTo(i, h);
            }
            ctx.stroke();
        });
        const matShell = new THREE.MeshStandardMaterial({ map: shellMap, roughness: 0.4 });

        // 5. Bloodshot Eyes
        const eyeMap = createCanvasTexture(256, 256, (ctx, w, h) => {
            ctx.fillStyle = '#fff0f0';
            ctx.fillRect(0,0,w,h);
            // Veins
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            for(let i=0; i<30; i++){
                ctx.beginPath();
                let x = w/2, y = h/2;
                ctx.moveTo(x,y);
                const ang = Math.random() * Math.PI * 2;
                ctx.quadraticCurveTo(x + Math.cos(ang)*50, y + Math.sin(ang)*50, x + Math.cos(ang)*120, y + Math.sin(ang)*120);
                ctx.stroke();
            }
        });
        const matEye = new THREE.MeshStandardMaterial({ map: eyeMap, roughness: 0.2, metalness: 0.1 });


        // --- SCENE OBJECTS ---

        // Floor
        const floorGeo = new THREE.PlaneGeometry(40, 40, 128, 128);
        const pos = floorGeo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            // Noisy terrain
            const x = pos.getX(i);
            const y = pos.getY(i);
            const z = 0.2 * Math.sin(x*0.5) * Math.cos(y*0.5) + Math.random() * 0.05;
            pos.setZ(i, z);
        }
        floorGeo.computeVertexNormals();
        const floor = new THREE.Mesh(floorGeo, matSand);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Bamboo Wall
        const bambooGroup = new THREE.Group();
        const bambooMat = new THREE.MeshStandardMaterial({ color: 0x182a36, roughness: 0.8 });
        for(let i=-20; i<20; i++) {
            // Variation in radius and tilt
            const r = 0.3 + Math.random()*0.1;
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 12, 8), bambooMat);
            cyl.position.set(i * 0.7, 5, -6 + (Math.random()*0.5));
            cyl.rotation.z = (Math.random()-0.5) * 0.1;
            cyl.rotation.x = (Math.random()-0.5) * 0.1;
            cyl.castShadow = true;
            cyl.receiveShadow = true;
            bambooGroup.add(cyl);
        }
        scene.add(bambooGroup);

        // --- CHARACTER: SPONGEBOB ---
        const bobGroup = new THREE.Group();

        // Deformed Box for Body (Not a perfect cube)
        const bodyGeo = new THREE.BoxGeometry(2, 2.2, 1, 16, 16, 4);
        const bPos = bodyGeo.attributes.position;
        const vector = new THREE.Vector3();
        for(let i=0; i<bPos.count; i++){
            vector.set(bPos.getX(i), bPos.getY(i), bPos.getZ(i));
            // Taper bottom slightly
            if(vector.y < 0) vector.x *= 0.9;
            // Sagging effect
            vector.y -= (vector.x * vector.x) * 0.05; 
            // Noise
            vector.x += (Math.random()-0.5)*0.02;
            vector.y += (Math.random()-0.5)*0.02;
            vector.z += (Math.random()-0.5)*0.02;
            bPos.setXYZ(i, vector.x, vector.y, vector.z);
        }
        bodyGeo.computeVertexNormals();

        // Split materials for Pants/Shirt/Sponge on one mesh? 
        // Easier to build separate parts for clarity.
        
        // 1. Sponge Head
        const headGeo = new THREE.BoxGeometry(2, 2, 1, 32, 32, 8);
        // Displace vertices for corners/waviness
        const hPos = headGeo.attributes.position;
        for(let i=0; i<hPos.count; i++){
            const x = hPos.getX(i), y = hPos.getY(i), z = hPos.getZ(i);
            const wave = Math.sin(x*4)*0.05 + Math.cos(y*4)*0.05;
            hPos.setXYZ(i, x+wave, y+wave, z);
        }
        headGeo.computeVertexNormals();
        const head = new THREE.Mesh(headGeo, matSponge);
        head.position.y = 1.5;
        head.castShadow = true;
        bobGroup.add(head);

        // 2. Shirt/Pants
        const pantsGroup = new THREE.Group();
        const shirtMat = new THREE.MeshStandardMaterial({color:0xeeeeee, roughness:0.9});
        const pantsMat = new THREE.MeshStandardMaterial({map: createNoiseTexture('#5c3a1e'), roughness:1}); // Brown
        
        const shirt = new THREE.Mesh(new THREE.BoxGeometry(2.02, 0.4, 1.02), shirtMat);
        shirt.position.y = 0.3;
        shirt.castShadow = true;
        pantsGroup.add(shirt);

        const pants = new THREE.Mesh(new THREE.BoxGeometry(2.02, 0.6, 1.02), pantsMat);
        pants.position.y = -0.2;
        pants.castShadow = true;
        pantsGroup.add(pants);

        // Tie
        const tie = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.6, 4), new THREE.MeshStandardMaterial({color:0xaa0000}));
        tie.rotation.z = Math.PI;
        tie.position.set(0, 0.15, 0.55);
        pantsGroup.add(tie);
        
        // Collar
        const collarL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), shirtMat);
        collarL.rotation.z = -0.5; collarL.position.set(-0.3, 0.45, 0.52);
        const collarR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), shirtMat);
        collarR.rotation.z = 0.5; collarR.position.set(0.3, 0.45, 0.52);
        pantsGroup.add(collarL, collarR);

        pantsGroup.position.y = 0.2;
        bobGroup.add(pantsGroup);

        // 3. Limbs (Skinny, bent)
        const limbMat = new THREE.MeshStandardMaterial({color: 0xffffaa, roughness: 0.5});
        
        // Legs (Sitting pose)
        const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8), limbMat);
        legL.position.set(-0.6, -0.3, 0.8);
        legL.rotation.x = -Math.PI/2 + 0.2;
        legL.castShadow = true;
        
        const legR = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8), limbMat);
        legR.position.set(0.6, -0.3, 0.8);
        legR.rotation.x = -Math.PI/2 + 0.2;
        legR.castShadow = true;

        bobGroup.add(legL, legR);

        // Socks & Shoes
        const sockGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.3);
        const sockMat = new THREE.MeshStandardMaterial({color: 0xffffff}); // Stripes handled by simple geometry logic? simplified to white
        const shoeGeo = new THREE.SphereGeometry(0.25, 16, 16);
        shoeGeo.applyMatrix4(new THREE.Matrix4().makeScale(1, 0.6, 1.4));
        const shoeMat = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.4});

        const footL = new THREE.Group();
        const sL = new THREE.Mesh(sockGeo, sockMat); sL.rotation.x = Math.PI/2; sL.position.z = -0.15;
        const shL = new THREE.Mesh(shoeGeo, shoeMat); shL.position.z = 0.1;
        footL.add(sL, shL);
        footL.position.set(-0.6, -0.45, 1.2);
        footL.rotation.x = -0.2; footL.rotation.z = -0.2; // Splayed
        
        const footR = footL.clone();
        footR.position.set(0.6, -0.45, 1.2);
        footR.rotation.z = 0.2;

        bobGroup.add(footL, footR);

        // Arms (Resting on chair)
        const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.4), limbMat);
        armL.position.set(-1.2, 1.0, 0.2);
        armL.rotation.z = Math.PI/3;
        armL.rotation.x = 0.2;
        
        const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.4), limbMat);
        armR.position.set(1.2, 1.0, 0.2);
        armR.rotation.z = -Math.PI/3;
        armR.rotation.x = 0.2;
        
        bobGroup.add(armL, armR);

        // Hands
        const handGeo = new THREE.SphereGeometry(0.15);
        const handL = new THREE.Mesh(handGeo, limbMat);
        handL.position.set(0, -0.7, 0);
        armL.add(handL);
        const handR = new THREE.Mesh(handGeo, limbMat);
        handR.position.set(0, -0.7, 0);
        armR.add(handR);

        // Cigarette in Left Hand
        const cig = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.4), new THREE.MeshBasicMaterial({color:0xffffff}));
        cig.rotation.x = Math.PI/2;
        cig.position.set(0.1, 0, 0.1);
        handL.add(cig);

        // Face Features
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.42, 32, 32);
        const eyeL = new THREE.Mesh(eyeGeo, matEye);
        eyeL.position.set(-0.45, 1.6, 0.45);
        const eyeR = new THREE.Mesh(eyeGeo, matEye);
        eyeR.position.set(0.45, 1.6, 0.45);
        bobGroup.add(eyeL, eyeR);

        // Pupils (Dilated)
        const pupilGeo = new THREE.SphereGeometry(0.16, 16, 16);
        const pupMat = new THREE.MeshStandardMaterial({color: 0x000000, roughness: 0});
        const pupL = new THREE.Mesh(pupilGeo, pupMat); pupL.position.set(0,0,0.38); pupL.scale.z = 0.2;
        const pupR = new THREE.Mesh(pupilGeo, pupMat); pupR.position.set(0,0,0.38); pupR.scale.z = 0.2;
        eyeL.add(pupL); eyeR.add(pupR);

        // Eyelids (Heavy)
        const lidGeo = new THREE.SphereGeometry(0.43, 32, 32, 0, Math.PI*2, 0, Math.PI/2.2);
        const lidMat = new THREE.MeshStandardMaterial({color: 0xccbb44, roughness: 0.8});
        const lidL = new THREE.Mesh(lidGeo, lidMat); lidL.rotation.x = Math.PI/1.9; lidL.position.copy(eyeL.position);
        const lidR = new THREE.Mesh(lidGeo, lidMat); lidR.rotation.x = Math.PI/1.9; lidR.position.copy(eyeR.position);
        bobGroup.add(lidL, lidR);

        // Bags under eyes
        const bagGeo = new THREE.TorusGeometry(0.3, 0.05, 8, 16, Math.PI);
        const bagMat = new THREE.MeshBasicMaterial({color: 0x887722, transparent: true, opacity: 0.5});
        const bagL = new THREE.Mesh(bagGeo, bagMat); bagL.position.set(-0.45, 1.55, 0.5); bagL.rotation.z = Math.PI;
        const bagR = new THREE.Mesh(bagGeo, bagMat); bagR.position.set(0.45, 1.55, 0.5); bagR.rotation.z = Math.PI;
        bobGroup.add(bagL, bagR);

        // Nose
        const nose = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.9), matSponge);
        nose.rotation.x = Math.PI/2;
        nose.position.set(0, 1.4, 0.8);
        bobGroup.add(nose);

        // Mouth (Frown)
        const mouthGeo = new THREE.TorusGeometry(0.6, 0.05, 8, 20, Math.PI/2);
        const mouth = new THREE.Mesh(mouthGeo, new THREE.MeshStandardMaterial({color:0x332200}));
        mouth.rotation.z = Math.PI * 0.75;
        mouth.position.set(0, 0.9, 0.52);
        bobGroup.add(mouth);

        // Teeth
        const toothGeo = new THREE.BoxGeometry(0.18, 0.25, 0.05);
        const toothMat = new THREE.MeshStandardMaterial({color:0xdddddd});
        const t1 = new THREE.Mesh(toothGeo, toothMat); t1.position.set(-0.12, 0.75, 0.52); t1.rotation.z = 0.1;
        const t2 = new THREE.Mesh(toothGeo, toothMat); t2.position.set(0.12, 0.75, 0.52); t2.rotation.z = -0.1;
        bobGroup.add(t1, t2);

        // Position Bob
        bobGroup.position.set(0.8, 0.8, 0);
        bobGroup.rotation.x = -0.2; // Slump
        bobGroup.castShadow = true;
        scene.add(bobGroup);

        // --- THE CHAIR ---
        const chairGroup = new THREE.Group();
        
        // Main Ring
        const ringGeo = new THREE.TorusGeometry(1.6, 0.7, 24, 48);
        const ring = new THREE.Mesh(ringGeo, matChair);
        ring.rotation.x = Math.PI/2;
        ring.scale.set(1, 1, 1);
        ring.castShadow = true;
        chairGroup.add(ring);
        
        // White Stripes
        const sGeo = new THREE.TorusGeometry(1.61, 0.71, 24, 16, 0.6);
        const strip1 = new THREE.Mesh(sGeo, matChairWhite); strip1.rotation.x=Math.PI/2; strip1.rotation.z=0.5;
        const strip2 = new THREE.Mesh(sGeo, matChairWhite); strip2.rotation.x=Math.PI/2; strip2.rotation.z=2.0;
        const strip3 = new THREE.Mesh(sGeo, matChairWhite); strip3.rotation.x=Math.PI/2; strip3.rotation.z=3.6; // Bottom
        chairGroup.add(strip1, strip2, strip3);

        // Backrest
        const backGeo = new THREE.CylinderGeometry(1.6, 1.6, 2.5, 32, 1, true, 3.5, 2.4); // Arc
        // Actually, let's build a solid back cushion
        const backCushion = new THREE.Mesh(new THREE.BoxGeometry(3.2, 3, 1.2), matChair);
        backCushion.position.set(0, 1.5, -1.3);
        // Add some displacement to look soft
        chairGroup.add(backCushion);

        chairGroup.position.set(0.8, 0.6, 0);
        scene.add(chairGroup);


        // --- CHARACTER: GARY ---
        const garyGroup = new THREE.Group();
        
        // Shell (Spiral Geometry)
        const shellSpine = [];
        for(let i=0; i<50; i++){
            const t = i/50;
            const angle = t * Math.PI * 4;
            const r = 0.1 + t * 0.8; // radius grows
            const y = t * 1.0; 
            shellSpine.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
        }
        // Approximation using a distorted sphere is often cleaner than tube for spiral shell in pure code
        const gShellGeo = new THREE.SphereGeometry(0.9, 32, 32);
        const gShell = new THREE.Mesh(gShellGeo, matShell);
        gShell.scale.set(0.8, 1.1, 0.8);
        gShell.position.y = 0.6;
        gShell.castShadow = true;
        garyGroup.add(gShell);

        // Body
        const gBodyGeo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 16);
        const gBodyMat = new THREE.MeshStandardMaterial({color: 0x7da1c4, roughness: 0.3, metalness: 0.1});
        const gBody = new THREE.Mesh(gBodyGeo, gBodyMat);
        gBody.rotation.x = Math.PI/2;
        gBody.position.set(0, 0.2, 0.5);
        garyGroup.add(gBody);

        // Eyes
        const stalkMat = new THREE.MeshStandardMaterial({color: 0x7da1c4});
        const stalkGeo = new THREE.CylinderGeometry(0.06, 0.1, 1.2);
        
        const stalkL = new THREE.Group();
        stalkL.position.set(-0.3, 0.4, 1.2);
        const sLm = new THREE.Mesh(stalkGeo, stalkMat); sLm.position.y=0.6; 
        const eyeBall = new THREE.Mesh(new THREE.SphereGeometry(0.25), matEye); eyeBall.position.y=1.2;
        const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({color:0xff0000})); pupil.position.set(0,1.35,0.15);
        stalkL.add(sLm, eyeBall, pupil);
        stalkL.rotation.x = 0.3; stalkL.rotation.z = 0.3;

        const stalkR = stalkL.clone();
        stalkR.position.set(0.3, 0.4, 1.2);
        stalkR.rotation.z = -0.3;

        garyGroup.add(stalkL, stalkR);
        
        garyGroup.position.set(-2.5, 0, 2);
        garyGroup.rotation.y = 0.8;
        scene.add(garyGroup);


        // --- THE TV (Foreground Silhouette) ---
        const tvGroup = new THREE.Group();
        
        // Casing
        const tvCaseGeo = new THREE.BoxGeometry(2.5, 2, 2);
        const tvMat = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.7});
        const tvCase = new THREE.Mesh(tvCaseGeo, tvMat);
        tvGroup.add(tvCase);

        // Antenna
        const antGeo = new THREE.CylinderGeometry(0.02, 0.02, 2);
        const ant1 = new THREE.Mesh(antGeo, new THREE.MeshStandardMaterial({color:0x888888}));
        ant1.position.set(-0.5, 1.5, 0); ant1.rotation.z = 0.5;
        const ant2 = new THREE.Mesh(antGeo, new THREE.MeshStandardMaterial({color:0x888888}));
        ant2.position.set(0.5, 1.5, 0); ant2.rotation.z = -0.5;
        tvGroup.add(ant1, ant2);

        // The Screen (Emitter)
        const screenGeo = new THREE.PlaneGeometry(2, 1.5);
        const screenMat = new THREE.MeshBasicMaterial({color: 0x88aaff});
        const tvScreen = new THREE.Mesh(screenGeo, screenMat);
        tvScreen.position.set(0, 0, -1.01); // Facing Back
        tvScreen.rotation.y = Math.PI; // Face towards Bob
        tvGroup.add(tvScreen);

        // TV Light Source
        const tvLight = new THREE.RectAreaLight(0x4488ff, 10, 2, 1.5);
        tvLight.position.set(0, 0, -1.1);
        tvLight.rotation.y = Math.PI;
        tvLight.lookAt(bobGroup.position);
        tvGroup.add(tvLight);

        // Place TV in foreground left
        tvGroup.position.set(-3, 1.5, 6);
        tvGroup.rotation.y = -0.5; // Angled towards Bob
        scene.add(tvGroup);


        // --- DEBRIS ---
        // Cans
        const canGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.45, 16);
        const canMat = new THREE.MeshStandardMaterial({color:0xaaaaaa, metalness:0.8, roughness:0.3});
        const redCanMat = new THREE.MeshStandardMaterial({color:0xcc2222, metalness:0.6, roughness:0.4});
        
        for(let i=0; i<20; i++){
            const can = new THREE.Mesh(canGeo, Math.random()>0.6 ? canMat : redCanMat);
            // Scatter
            can.position.set((Math.random()-0.5)*10, 0.25, (Math.random()-0.5)*8 + 2);
            can.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
            can.castShadow = true;
            scene.add(can);
        }

        // Cigarette Butts
        const buttGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.12);
        const buttMat = new THREE.MeshBasicMaterial({color: 0xcc8800});
        for(let i=0; i<40; i++){
            const b = new THREE.Mesh(buttGeo, buttMat);
            b.position.set((Math.random()-0.5)*8, 0.05, (Math.random()-0.5)*8 + 1);
            b.rotation.x = Math.PI/2;
            b.rotation.y = Math.random()*3;
            scene.add(b);
        }

        // Empty Bottle
        const bottleGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 16);
        const bottleMat = new THREE.MeshPhysicalMaterial({
            color: 0x225522, transmission: 0.8, opacity: 1, roughness: 0.1, thickness: 0.1
        });
        const bottle = new THREE.Mesh(bottleGeo, bottleMat);
        bottle.position.set(2.5, 0.3, 3);
        bottle.castShadow = true;
        scene.add(bottle);


        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0x051020, 0.2);
        scene.add(ambient);

        // Dirty Overhead Lamp
        const spot = new THREE.SpotLight(0xffddaa, 100);
        spot.position.set(2, 10, 2);
        spot.angle = 0.5;
        spot.penumbra = 0.5;
        spot.castShadow = true;
        spot.shadow.bias = -0.001;
        scene.add(spot);

        // Rim Light (Cool Blue from back left)
        const rim = new THREE.SpotLight(0x0044ff, 80);
        rim.position.set(-8, 5, -5);
        rim.lookAt(bobGroup.position);
        scene.add(rim);

        // --- SMOKE PARTICLES ---
        const smokeParticles = [];
        const smokeGeo = new THREE.PlaneGeometry(1,1);
        // Create soft smoke texture
        const smokeTex = createCanvasTexture(128,128, (ctx, w, h) => {
            const g = ctx.createRadialGradient(w/2,h/2, 0, w/2,h/2, w/2);
            g.addColorStop(0, 'rgba(200,200,200,0.5)');
            g.addColorStop(1, 'rgba(200,200,200,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,w,h);
        });
        const smokeMat = new THREE.MeshBasicMaterial({
            map: smokeTex, transparent: true, opacity: 0.3, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });

        function createSmokeParticle(pos) {
            const p = new THREE.Mesh(smokeGeo, smokeMat);
            p.position.copy(pos);
            p.scale.set(0.1, 0.1, 0.1);
            // Random velocity
            p.userData = {
                vel: new THREE.Vector3((Math.random()-0.5)*0.01, 0.02 + Math.random()*0.01, (Math.random()-0.5)*0.01),
                age: 0,
                life: 2 + Math.random()
            };
            scene.add(p);
            smokeParticles.push(p);
        }

        // Helpers
        function createNoiseTexture(color) {
            return createCanvasTexture(256, 256, (ctx, w, h) => {
                ctx.fillStyle = color; ctx.fillRect(0,0,w,h);
                noise(ctx,w,h,30);
            });
        }


        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        document.getElementById('loader').style.display = 'none';

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            controls.update();

            // TV Flicker
            const intensity = 5 + Math.sin(time * 15)*2 + Math.cos(time * 35)*3 + Math.random()*3;
            tvLight.intensity = Math.max(0, intensity);
            tvScreen.material.color.setHSL(0.6, 0.5, 0.5 + intensity/30);

            // Smoke Emission from cigarette
            // Calculate world position of cigarette tip
            const handWorld = new THREE.Vector3();
            handL.getWorldPosition(handWorld);
            // Offset slightly for tip
            handWorld.add(new THREE.Vector3(0.1, 0.1, 0)); 

            if(Math.random() > 0.7) createSmokeParticle(handWorld);

            // Update Smoke
            for(let i=smokeParticles.length-1; i>=0; i--){
                const p = smokeParticles[i];
                p.position.add(p.userData.vel);
                p.userData.age += dt;
                const s = 0.1 + (p.userData.age * 0.3); // Grow
                p.scale.set(s,s,s);
                p.lookAt(camera.position);
                p.material.opacity = 0.3 * (1 - p.userData.age/p.userData.life);

                if(p.userData.age >= p.userData.life){
                    scene.remove(p);
                    smokeParticles.splice(i, 1);
                }
            }

            // Subtle idle animations
            bobGroup.position.y = 0.8 + Math.sin(time * 0.5) * 0.01;
            stalkL.rotation.z = 0.3 + Math.sin(time)*0.05;
            stalkR.rotation.z = -0.3 + Math.cos(time)*0.05;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
