<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mood Scene: SpongeBob & Gary</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #05070a; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-family: sans-serif; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">Generating Scene...</div>

    <!-- Import Three.js and OrbitControls from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        // Deep dark blue fog for the underwater/murky atmosphere
        scene.fog = new THREE.FogExp2(0x050a14, 0.035);
        scene.background = new THREE.Color(0x050a14);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(-4, 2.5, 8); // Similar angle to reference
        camera.lookAt(1, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        // --- PROCEDURAL TEXTURE GENERATORS ---
        // Helper to create gritty textures without external images
        function createNoiseTexture(colorBase, noiseIntensity = 50) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = colorBase;
            ctx.fillRect(0,0,512,512);
            
            const imgData = ctx.getImageData(0,0,512,512);
            for(let i=0; i<imgData.data.length; i+=4) {
                const grain = (Math.random() - 0.5) * noiseIntensity;
                imgData.data[i] += grain;
                imgData.data[i+1] += grain;
                imgData.data[i+2] += grain;
            }
            ctx.putImageData(imgData, 0, 0);
            
            // Add some "grime" spots
            for(let i=0; i<20; i++){
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(Math.random()*512, Math.random()*512, Math.random()*50, 0, Math.PI*2);
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        const spongeTexture = createNoiseTexture('#c4b835', 40); // Dirty Yellow
        const pantsTexture = createNoiseTexture('#5c3a1e', 20);  // Brown
        const skinTexture = createNoiseTexture('#fffdd0', 10);   // Shirt
        const sandTexture = createNoiseTexture('#3d362b', 60);   // Dark Sand
        const shellTexture = createNoiseTexture('#d46e8b', 40);  // Pinkish
        const chairTexture = createNoiseTexture('#8a2828', 60);  // Worn Red
        const metalTexture = createNoiseTexture('#444444', 80);  // Metal

        // --- MATERIALS ---
        const matSponge = new THREE.MeshStandardMaterial({ map: spongeTexture, roughness: 0.9, bumpMap: spongeTexture, bumpScale: 0.05 });
        const matShirt = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
        const matPants = new THREE.MeshStandardMaterial({ map: pantsTexture, roughness: 1.0 });
        const matTie = new THREE.MeshStandardMaterial({ color: 0x880000, roughness: 0.8 });
        const matSkin = new THREE.MeshStandardMaterial({ color: 0xffffcc, roughness: 0.5 });
        const matChair = new THREE.MeshStandardMaterial({ map: chairTexture, roughness: 0.6 });
        const matChairWhite = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.7 });
        const matGaryShell = new THREE.MeshStandardMaterial({ map: shellTexture, roughness: 0.4 });
        const matGaryBody = new THREE.MeshStandardMaterial({ color: 0x7da1c4, roughness: 0.6 }); // Blueish
        const matEye = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
        const matPupil = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const matRedEye = new THREE.MeshStandardMaterial({ color: 0xffcccc, roughness: 0.4 }); // Bloodshot

        // --- ENVIRONMENT ---
        
        // Floor (Sand)
        const floorGeo = new THREE.PlaneGeometry(30, 30, 64, 64);
        // Add noise to vertices for sand dunes
        const pos = floorGeo.attributes.position;
        for(let i=0; i<pos.count; i++){
            pos.setZ(i, Math.random() * 0.15);
        }
        floorGeo.computeVertexNormals();
        const floor = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({ map: sandTexture, roughness: 1, bumpMap: sandTexture, bumpScale: 0.2 }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Wall (Corrugated Metal/Bamboo)
        const wallGroup = new THREE.Group();
        for(let i=0; i<40; i++) {
            const plank = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 10, 8),
                new THREE.MeshStandardMaterial({ color: 0x1a2b3c, roughness: 0.8 })
            );
            plank.position.set(-10 + (i * 0.5), 5, -5);
            plank.castShadow = true;
            plank.receiveShadow = true;
            wallGroup.add(plank);
        }
        scene.add(wallGroup);

        // --- CHARACTERS ---

        // 1. SpongeBob
        const bobGroup = new THREE.Group();
        
        // Head (Sponge)
        const headGeo = new THREE.BoxGeometry(1.8, 1.8, 0.8);
        const head = new THREE.Mesh(headGeo, matSponge);
        head.position.y = 1.6;
        head.castShadow = true;
        bobGroup.add(head);

        // Shirt
        const shirt = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.3, 0.8), matShirt);
        shirt.position.y = 0.55;
        shirt.castShadow = true;
        bobGroup.add(shirt);

        // Pants
        const pants = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 0.8), matPants);
        pants.position.y = 0.15;
        pants.castShadow = true;
        bobGroup.add(pants);

        // Tie
        const tieGeo = new THREE.ConeGeometry(0.15, 0.6, 4);
        const tie = new THREE.Mesh(tieGeo, matTie);
        tie.rotation.z = Math.PI;
        tie.position.set(0, 0.4, 0.45);
        bobGroup.add(tie);

        // Eyes (Tired)
        const eyeGeo = new THREE.SphereGeometry(0.35, 32, 32);
        const eyeL = new THREE.Mesh(eyeGeo, matRedEye);
        const eyeR = new THREE.Mesh(eyeGeo, matRedEye);
        eyeL.position.set(-0.4, 1.6, 0.35);
        eyeR.position.set(0.4, 1.6, 0.35);
        bobGroup.add(eyeL, eyeR);

        // Pupils
        const pupilGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const pupL = new THREE.Mesh(pupilGeo, matPupil);
        const pupR = new THREE.Mesh(pupilGeo, matPupil);
        pupL.position.set(-0.4, 1.6, 0.65);
        pupR.position.set(0.4, 1.6, 0.65);
        bobGroup.add(pupL, pupR);

        // Eyelids (Half closed)
        const lidGeo = new THREE.SphereGeometry(0.36, 32, 32, 0, Math.PI * 2, 0, Math.PI/2.5);
        const lidL = new THREE.Mesh(lidGeo, matSponge);
        lidL.rotation.x = Math.PI / 1.8;
        lidL.position.set(-0.4, 1.6, 0.35);
        const lidR = new THREE.Mesh(lidGeo, matSponge);
        lidR.rotation.x = Math.PI / 1.8;
        lidR.position.set(0.4, 1.6, 0.35);
        bobGroup.add(lidL, lidR);

        // Nose
        const nose = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.8), matSponge);
        nose.rotation.x = Math.PI / 2;
        nose.position.set(0, 1.4, 0.6);
        bobGroup.add(nose);

        // Arms (Slumped)
        const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2);
        const armL = new THREE.Mesh(armGeo, matSponge);
        armL.rotation.z = Math.PI / 3;
        armL.position.set(-1.3, 0.8, 0);
        const armR = new THREE.Mesh(armGeo, matSponge);
        armR.rotation.z = -Math.PI / 3;
        armR.position.set(1.3, 0.8, 0);
        bobGroup.add(armL, armR);

        // Legs (Sitting)
        const legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8);
        const legL = new THREE.Mesh(legGeo, matSponge);
        legL.rotation.x = -Math.PI / 2;
        legL.position.set(-0.5, 0.2, 0.6);
        const legR = new THREE.Mesh(legGeo, matSponge);
        legR.rotation.x = -Math.PI / 2;
        legR.position.set(0.5, 0.2, 0.6);
        bobGroup.add(legL, legR);
        
        // Shoes
        const shoeGeo = new THREE.SphereGeometry(0.25);
        const shoeL = new THREE.Mesh(shoeGeo, new THREE.MeshStandardMaterial({color: 0x111111}));
        shoeL.scale.set(1, 0.5, 1.5);
        shoeL.position.set(-0.5, 0.1, 1.1);
        const shoeR = shoeL.clone();
        shoeR.position.set(0.5, 0.1, 1.1);
        bobGroup.add(shoeL, shoeR);

        // Position SpongeBob
        bobGroup.position.set(1, 0.5, 0);
        bobGroup.rotation.x = -0.2; // Slouching back
        scene.add(bobGroup);


        // 2. The Chair (Life Ring Style)
        const chairGroup = new THREE.Group();
        
        // Seat Ring
        const ringGeo = new THREE.TorusGeometry(1.5, 0.6, 16, 50);
        const seat = new THREE.Mesh(ringGeo, matChair);
        seat.rotation.x = Math.PI / 2;
        seat.position.y = 0.6;
        seat.scale.set(1, 1, 1.5); // Oval shape
        chairGroup.add(seat);

        // Add white stripes to chair
        const strip1 = new THREE.Mesh(new THREE.TorusGeometry(1.51, 0.61, 16, 16, 0.5), matChairWhite);
        strip1.rotation.x = Math.PI/2; strip1.rotation.z = 0.5; strip1.position.y = 0.6; strip1.scale.set(1,1,1.5);
        const strip2 = new THREE.Mesh(new THREE.TorusGeometry(1.51, 0.61, 16, 16, 0.5), matChairWhite);
        strip2.rotation.x = Math.PI/2; strip2.rotation.z = 2.5; strip2.position.y = 0.6; strip2.scale.set(1,1,1.5);
        chairGroup.add(strip1, strip2);

        // Backrest
        const backGeo = new THREE.CylinderGeometry(1.8, 1.8, 2.5, 32, 1, true, 0, Math.PI);
        const back = new THREE.Mesh(backGeo, matChair);
        back.position.set(0, 2, -0.8);
        back.scale.set(1, 1, 0.5);
        // Make it double sided or add thickness? Let's just use a thick torus segment for top
        const backTop = new THREE.Mesh(new THREE.TorusGeometry(1.8, 0.5, 16, 32, Math.PI), matChair);
        backTop.position.set(0, 3.25, -0.8);
        backTop.rotation.z = Math.PI / 2; // Incorrect rotation fix below
        backTop.rotation.set(0,0,0); // Reset
        
        // Simpler backrest approach: Group of cylinders
        const backRestMesh = new THREE.Mesh(new THREE.BoxGeometry(3.5, 3, 1), matChair);
        backRestMesh.position.set(0, 2.2, -1.2);
        chairGroup.add(backRestMesh);

        chairGroup.position.set(1, 0, 0);
        scene.add(chairGroup);


        // 3. Gary
        const garyGroup = new THREE.Group();
        
        // Shell (Pink Spiral) - Approximated with a distorted Sphere/Lathe
        const shellGeo = new THREE.SphereGeometry(0.8, 32, 32);
        const shell = new THREE.Mesh(shellGeo, matGaryShell);
        shell.scale.set(1, 1.2, 1);
        shell.position.y = 0.8;
        garyGroup.add(shell);

        // Body
        const bodyGeo = new THREE.SphereGeometry(0.5, 32, 32);
        const body = new THREE.Mesh(bodyGeo, matGaryBody);
        body.scale.set(1, 0.6, 1.5);
        body.position.y = 0.3;
        body.position.z = 0.5;
        garyGroup.add(body);

        // Eye Stalks
        const stalkGeo = new THREE.CylinderGeometry(0.05, 0.08, 0.8);
        const stalkL = new THREE.Mesh(stalkGeo, matGaryBody);
        stalkL.position.set(-0.25, 1.2, 1.0);
        stalkL.rotation.x = 0.2;
        stalkL.rotation.z = 0.2;
        
        const stalkR = new THREE.Mesh(stalkGeo, matGaryBody);
        stalkR.position.set(0.25, 1.2, 1.0);
        stalkR.rotation.x = 0.2;
        stalkR.rotation.z = -0.2;
        garyGroup.add(stalkL, stalkR);

        // Eyes
        const gEyeGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const gEyeL = new THREE.Mesh(gEyeGeo, matEye);
        gEyeL.position.set(0, 0.4, 0);
        stalkL.add(gEyeL);
        const gEyeR = new THREE.Mesh(gEyeGeo, matEye);
        gEyeR.position.set(0, 0.4, 0);
        stalkR.add(gEyeR);

        // Red Pupils
        const gPupGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const gPupL = new THREE.Mesh(gPupGeo, new THREE.MeshBasicMaterial({color:0xff0000}));
        gPupL.position.set(0, 0.15, 0.12);
        gEyeL.add(gPupL);
        const gPupR = new THREE.Mesh(gPupGeo, new THREE.MeshBasicMaterial({color:0xff0000}));
        gPupR.position.set(0, 0.15, 0.12);
        gEyeR.add(gPupR);

        garyGroup.position.set(-1.5, 0, 2);
        garyGroup.rotation.y = 0.5;
        scene.add(garyGroup);


        // --- PROPS & DEBRIS (Cans, Bottles, Butts) ---
        
        // Can Geometry
        const canGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 16);
        const canMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });
        const redCanMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.6 });

        for(let i=0; i<15; i++){
            const can = new THREE.Mesh(canGeo, Math.random()>0.5 ? canMat : redCanMat);
            can.position.set(
                (Math.random() - 0.5) * 8,
                0.2,
                (Math.random() - 0.5) * 6 + 2
            );
            can.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            can.castShadow = true;
            scene.add(can);
        }

        // Cigarette Butts
        const buttGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.15);
        const buttMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 }); // Filter color
        
        for(let i=0; i<30; i++){
            const butt = new THREE.Mesh(buttGeo, buttMat);
            butt.position.set(
                (Math.random() - 0.5) * 6,
                0.05,
                (Math.random() - 0.5) * 6 + 1
            );
            butt.rotation.x = Math.PI/2;
            butt.rotation.y = Math.random() * Math.PI;
            scene.add(butt);
        }
        
        // Cigarette in hand
        const cig = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3), new THREE.MeshBasicMaterial({color: 0xffffff}));
        cig.rotation.z = Math.PI/2;
        cig.position.set(-0.2, -0.6, 0); // Relative to arm
        armL.add(cig);

        // Bottle on table
        const table = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.1), new THREE.MeshStandardMaterial({color:0x3d2614}));
        table.position.set(3.5, 0.8, 1);
        // Legs for table
        const tLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8), new THREE.MeshStandardMaterial({color:0x3d2614}));
        tLeg.position.y = -0.4;
        table.add(tLeg);
        scene.add(table);

        const bottle = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.6), new THREE.MeshStandardMaterial({color: 0x224422, transparent: true, opacity: 0.8}));
        bottle.position.set(0, 0.35, 0);
        table.add(bottle);


        // --- LIGHTING (Cinematic) ---
        
        const ambientLight = new THREE.AmbientLight(0x112233, 0.3); // Dark Blue Ambient
        scene.add(ambientLight);

        // Key Light (Top Right, Warm/Dirty) simulates the lamp in the room
        const spotLight = new THREE.SpotLight(0xffeebb, 150);
        spotLight.position.set(5, 8, 5);
        spotLight.target.position.set(0, 0, 0);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.bias = -0.0001;
        scene.add(spotLight);
        scene.add(spotLight.target);

        // Rim Light / Fill (Cool Blue from left/back)
        const rimLight = new THREE.PointLight(0x0044ff, 50, 10);
        rimLight.position.set(-5, 3, -2);
        scene.add(rimLight);

        // TV Glow / Low angle light (Front, Flickering)
        const tvLight = new THREE.PointLight(0xaaccff, 20, 10);
        tvLight.position.set(-2, 1, 6);
        scene.add(tvLight);

        // --- PARTICLES (Floating Dust/Smoke) ---
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 1000;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i=0; i<particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 15;
        }
        
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.05,
            color: 0xaabbcc,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        const particleSystem = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleSystem);


        // --- ANIMATION ---
        document.getElementById('loading').style.display = 'none';

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            controls.update();

            // Flicker TV light
            tvLight.intensity = 10 + Math.sin(time * 10) * 5 + Math.random() * 5;

            // Float particles
            particleSystem.rotation.y = time * 0.05;
            particleSystem.position.y = Math.sin(time * 0.2) * 0.2;

            // Subtle breathing for SpongeBob
            bobGroup.scale.y = 1 + Math.sin(time * 2) * 0.005;
            
            // Gary Eye movement (subtle)
            stalkL.rotation.z = 0.2 + Math.sin(time) * 0.05;
            stalkR.rotation.z = -0.2 + Math.cos(time) * 0.05;

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
